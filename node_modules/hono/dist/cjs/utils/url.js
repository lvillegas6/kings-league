"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var url_exports = {};
__export(url_exports, {
  checkOptionalParameter: () => checkOptionalParameter,
  getPathFromURL: () => getPathFromURL,
  getPattern: () => getPattern,
  getQueryParam: () => getQueryParam,
  getQueryParams: () => getQueryParams,
  getQueryStringFromURL: () => getQueryStringFromURL,
  mergePath: () => mergePath,
  splitPath: () => splitPath,
  splitRoutingPath: () => splitRoutingPath
});
module.exports = __toCommonJS(url_exports);
const splitPath = (path) => {
  const paths = path.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  return paths;
};
const splitRoutingPath = (path) => {
  const groups = [];
  for (let i = 0; ; ) {
    let replaced = false;
    path = path.replace(/\{[^}]+\}/g, (m) => {
      const mark = `@\\${i}`;
      groups[i] = [mark, m];
      i++;
      replaced = true;
      return mark;
    });
    if (!replaced) {
      break;
    }
  }
  const paths = path.split("/");
  if (paths[0] === "") {
    paths.shift();
  }
  for (let i = groups.length - 1; i >= 0; i--) {
    const [mark] = groups[i];
    for (let j = paths.length - 1; j >= 0; j--) {
      if (paths[j].indexOf(mark) !== -1) {
        paths[j] = paths[j].replace(mark, groups[i][1]);
        break;
      }
    }
  }
  return paths;
};
const patternCache = {};
const getPattern = (label) => {
  if (label === "*") {
    return "*";
  }
  const match = label.match(/^\:([^\{\}]+)(?:\{(.+)\})?$/);
  if (match) {
    if (!patternCache[label]) {
      if (match[2]) {
        patternCache[label] = [label, match[1], new RegExp("^" + match[2] + "$")];
      } else {
        patternCache[label] = [label, match[1], true];
      }
    }
    return patternCache[label];
  }
  return null;
};
const getPathFromURL = (url, strict = true) => {
  const queryIndex = url.indexOf("?", 8);
  const result = url.substring(url.indexOf("/", 8), queryIndex === -1 ? url.length : queryIndex);
  if (strict === false && result.endsWith("/")) {
    return result.slice(0, -1);
  }
  return result;
};
const getQueryStringFromURL = (url) => {
  const queryIndex = url.indexOf("?", 8);
  const result = queryIndex !== -1 ? url.slice(queryIndex + 1) : "";
  return result;
};
const mergePath = (...paths) => {
  let p = "";
  let endsWithSlash = false;
  for (let path of paths) {
    if (p.endsWith("/")) {
      p = p.slice(0, -1);
      endsWithSlash = true;
    }
    if (!path.startsWith("/")) {
      path = `/${path}`;
    }
    if (path === "/" && endsWithSlash) {
      p = `${p}/`;
    } else if (path !== "/") {
      p = `${p}${path}`;
    }
    if (path === "/" && p === "") {
      p = "/";
    }
  }
  return p;
};
const checkOptionalParameter = (path) => {
  const match = path.match(/(^.+)(\/\:[^\/]+)\?$/);
  if (!match)
    return null;
  const base = match[1];
  const optional = base + match[2];
  return [base, optional];
};
const removeFragment = (queryString) => {
  const fragIndex = queryString.indexOf("#");
  if (fragIndex !== -1) {
    queryString = queryString.slice(0, fragIndex);
  }
  return queryString;
};
const getQueryParam = (queryString, key) => {
  queryString = removeFragment(queryString);
  const results = {};
  while (true) {
    const andIndex = queryString.indexOf("&");
    let strings = "";
    if (andIndex === -1) {
      strings = queryString;
    } else {
      strings = queryString.substring(0, andIndex);
    }
    const eqIndex = strings.indexOf("=");
    if (eqIndex !== -1) {
      const v = strings.substring(eqIndex + 1);
      const k = strings.substring(0, eqIndex);
      if (key === k) {
        return /\%/.test(v) ? decodeURI(v) : v;
      } else {
        results[k] || (results[k] = v);
      }
    } else if (strings === key) {
      return "";
    }
    if (andIndex === -1)
      break;
    queryString = queryString.substring(andIndex + 1, queryString.length);
  }
  if (key)
    return null;
  return results;
};
const getQueryParams = (queryString, key) => {
  queryString = removeFragment(queryString);
  const results = {};
  for (const strings of queryString.split("&")) {
    let [k, v] = strings.split("=");
    if (v === void 0)
      v = "";
    results[k] || (results[k] = []);
    results[k].push(v.indexOf("%") !== -1 ? decodeURI(v) : v);
  }
  if (key)
    return results[key] ? results[key] : null;
  return results;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  checkOptionalParameter,
  getPathFromURL,
  getPattern,
  getQueryParam,
  getQueryParams,
  getQueryStringFromURL,
  mergePath,
  splitPath,
  splitRoutingPath
});
